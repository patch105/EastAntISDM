
## Background sampling = everywhere in East Antarctica

## MaxNet (using glmnet)


# Convert input data to a matrix
# Make quadratic terms for glmnet package

# To make the orthogonal quadratic features for glmnet package (see more detail in the supplementary material
# of Guillera-Arroita et al. 2014), the make_quadratic function in myspatial package is used. The object
# generated by this function can be used in the generic predict() function to apply the transformation on the
# training and testing datasets and later used in predicting to rasters. The package myspatial is archived in
# GitHub and can be installed using the following code.

# installing the package from github
# remotes::install_github("rvalavi/myspatial")

library(glmnet)
library(myspatial)

quad_obj <- make_quadratic(train_PB_covs, cols = cov_names)

# now we can predict this quadratic object on the training and testing data
# this make two columns for each covariates used in the transformation
training_quad <- predict(quad_obj, newdata = train_PB_covs)
predict_quad <- predict(quad_obj, newdata = predict_covs)

# convert the data.frames to sparse matrices
# select all quadratic (and non-quadratic) columns, except the y (occ)

new_vars <- names(training_quad)[names(training_quad) != c("ID", "Presence")]
training_sparse <- sparse.model.matrix(~. -1, training_quad[, new_vars])
predict_sparse <- sparse.model.matrix(~. -1, predict_quad[, new_vars])

#  calculating the case weights
# WEIGHTING BY MAKING BACKGROUND POINTS HAVE A REALLY LARGE WEIGHT (= IW)

# Fitting the GLM (update for MaxNet implementation)

lasso <- glmnet(x = training_sparse,
                y = training_quad$Presence,
                family = "binomial",
                alpha = 1, # here 1 means fitting lasso
                weights = wt)

plot(lasso, xvar = "lambda", label = TRUE)

lasso_cv <- cv.glmnet(x = training_sparse,
                      y = training_quad$Presence,
                      family = "binomial",
                      alpha = 1, # here 1 means fitting lasso
                      weights = wt,
                      nfolds = 10) # number of folds for cross-validation

plot(lasso_cv)

# Choose to use the lambda (regularisation parameter) that is 1SD from the minimum deviance (to avoid over-fitting if use the minimum deviance lambda)

pred_lasso_cv <- predict(lasso_cv, predict_sparse, s = "lambda.1se", type = "response")

# Convert the prediction to a raster

pred_lasso_cv <- cbind(predict_covs, pred_lasso_cv)

pred.rast <- rast(pred_lasso_cv[, c("x", "y", "lambda.1se")], type = "xyz", crs = "EPSG:3031")

plet(pred.rast, "lambda.1se", tiles = "")

